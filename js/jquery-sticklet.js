// Generated by CoffeeScript 1.4.0
(function() {
  var activate, applyBounds, calculateLimit, deactivate, intersect, lastScroll, limitRegex, onScroll, parseLimit, position, targets, win;

  targets = [];

  limitRegex = /^(below|above|topline|bottomline)\s+(\S+)$/;

  win = $(window);

  lastScroll = null;

  $.fn.sticklet = function() {
    var limit, limits, str, _i, _len;
    limits = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      str = arguments[_i];
      limit = parseLimit(str);
      if (limit.element.length > 0) {
        limits.push(limit);
      }
    }
    this.each(function() {
      var el, id;
      el = $(this);
      id = el.data('stickletId');
      if (!targets[id]) {
        id = targets.length;
        el.data('sticklet-id', id);
        targets.push({
          element: el,
          initialTop: Number(el.css('top'))
        });
      }
      return targets[id].limits = limits;
    });
    activate();
    return this;
  };

  activate = function() {
    return win.on('scroll', onScroll);
  };

  deactivate = function() {
    return win.off('scroll', onScroll);
  };

  onScroll = function() {
    var scroll, target, _i, _len;
    scroll = win.scrollTop();
    if (scroll !== lastScroll) {
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        position(target);
      }
      return lastScroll = scroll;
    }
  };

  position = function(target) {
    var bounds, conditions, limit;
    conditions = (function() {
      var _i, _len, _ref, _results;
      _ref = target.limits;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        limit = _ref[_i];
        _results.push(calculateLimit(target.element, limit));
      }
      return _results;
    })();
    bounds = intersect(conditions);
    console.log(bounds);
    return applyBounds(target, bounds);
  };

  applyBounds = function(target, bounds) {
    if (bounds.reverse) {
      return target.element.offset({
        top: bounds.max
      });
    } else {
      return target.element.offset({
        top: bounds.min
      });
    }
  };

  intersect = function(conditions) {
    var bounds, rule, _i, _len;
    bounds = {
      min: Number.MIN_VALUE,
      max: Number.MAX_VALUE
    };
    for (_i = 0, _len = conditions.length; _i < _len; _i++) {
      rule = conditions[_i];
      if (!rule.reverse) {
        if (rule.min <= bounds.max) {
          bounds.min = Math.max(bounds.min, rule.min);
          bounds.reverse = false;
        } else {
          return bounds;
        }
      } else {
        if (rule.max >= bounds.min) {
          bounds.max = Math.min(bounds.max, rule.max);
          bounds.reverse = true;
        } else {
          return bounds;
        }
      }
    }
    return bounds;
  };

  calculateLimit = function(target, limit) {
    var limitHeight, limitTop, targetHeight;
    limitTop = limit.element.offset().top;
    limitHeight = limit.element.height();
    targetHeight = target.height();
    if (limit.position === 'below') {
      return {
        min: limitTop + limitHeight,
        reverse: false
      };
    }
    if (limit.position === 'topline') {
      return {
        min: limitTop,
        reverse: false
      };
    }
    if (limit.position === 'above') {
      return {
        max: limitTop - targetHeight,
        reverse: true
      };
    }
    if (limit.position === 'bottomline') {
      return {
        max: limitTop + limitHeight - targetHeight,
        reverse: true
      };
    }
  };

  parseLimit = function(str) {
    var match, selector;
    match = limitRegex.exec(str);
    selector = match[2];
    return {
      position: match[1],
      element: $(selector)
    };
  };

}).call(this);
